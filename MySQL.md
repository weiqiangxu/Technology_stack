MySQL基础题

1、什么是主键、外键
	能够唯一表示数据表中的每个记录的字段或者字段的组合就称为主键,不能为空,具有唯一性。
	若有两个表A,B,C是A的主键,而B中也有C字段,则C就是表B的外键,外键约束主要用来维护两个表之间数据的一致性。
	外键一定是另外某个表的主键。

2、说一下数据库事务的特性
	四个,原子、一致、隔离、持久。
	根据事务之间四种隔离级别可能会出现脏读(读到未提交)|不可重复读(事务内读取到其他事务提交数据,一个事务内读到2个不同的数据)|幻读(一个事务开始读到总数为1之后读到2,这个2是因为读到其他已提交事务的更改)。
	Serializable (事务串行化)可避免脏读、不可重复读、幻读的发生。
	Repeatable read (可重复读)可避免脏读、不可重复读的发生。
	Read committed (读已提交)可避免脏读的发生。
	Read uncommitted (读未提交)最低级别,任何情况都无法保证。


3、视图有什么用
	是一个虚拟表,隐藏数据的复杂性,数据库视图使用户查询变得简单,用户只能看到视图的数据隐藏其他的列。

4、drop,delete与truncate的区别
	delete删除行会记录在日志中,truncat删除不能恢复,drop将表结构删了

5、什么是索引,种类有哪些,索引方法有哪些
	索引是对数据库表中一列或多列的值进行排序的一种结构,使用索引可快速访问数据库表中的特定信息。
	类型:FULLTEXT,HASH,BTREE,RTREE。
	种类:普通|唯一|主键|组合|全文

6、说一下你对优化MySQL的看法
	硬件优化:cpu内存
	系统参数优化:最大连接数,query_cache_size,存储引擎选取
	查询语句优化:慢查日志记录,少join表,避免全表扫描,避免null值,偏移大时between比limit快,尽量数字类型,缩小数据集,
	表结构优化:字段选取,索引选取
	架构优化:读写分离-分区分表

7、select * from table1 where name=''zhangsan'' and tID > 10000和执行select * from table1 where tID > 10000 and name=''zhangsan''的速度是否一样
	一样,MySQL的查询优化器会自动选取

8、索引失效,全表扫描的情况有哪些
	where条件中有null、NOT条件、like前置通配符'%abc'、数据类型转换id='123'

9、简单说一下什么是聚集索引、非聚集索引
	聚集:索引中键值的逻辑顺序决定了表中相应行的物理顺序-电话区号、日期 - 迅速缩小查询范围，避免全表扫描
	非聚集:该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同
	
10、decimal(M,D)、float(M,D)、double(M,D)的区别是什么,说一下各自的使用场景
	M是标度,D是精度,D是小数点后的位数,float会出现精度丢失,decimal则不会它以字符串形式存储

11、int(M)的M有什么用、float(M,D)的M和D呢、varchar(M)和char(M)的M又是干嘛的(字节数还是字符数)
	int(M)的M部分MySQL显示长度控制,char和varchar的为能存储的字符数

12、varchar的最大长度是多少
	MySQL行长度字节数限制最大65535,字符数依据编码格式gbk:1个字符最多2个字节.utf8:1个字符最多3个字节

13、一个字节等于多少bit,MySQL的int能存储的字节数是4字节,那么你怎么换算他的取值范围
	1bit就是1个2进制位其值不是0就是1,1byte=8bit即一个字节8位,4个字节就是32个0或1,假定为32个1转换为十进制就是4294967295,那么就是0-4294967295

14、Navicat给table建立索引的时候,索引类型有哪些,索引方法有哪些,各自的适用场景是什么
https://www.cnblogs.com/luyucheng/p/6289714.html

15、简述MySQL索引方法hash\btree两种的优缺点、适用场景
https://www.cnblogs.com/luyucheng/p/6289048.html
https://www.cnblogs.com/yuan-shuai/p/3225417.html

16、进行模糊查找的时候like '%abc%''\like 'abc%'会导致全表扫描吗

17、子查询跟join表哪个更快
	子查询会新建一个临时表,当表数据小用子查询,大用join表

18、简述MySQL的存储引擎MyISAM、InnoDB的各自的优缺点(至少5点)以及适用场景

myisam优点:支持FULLTEXT类型全文索引,MyISAM引擎的表的查询、更新、插入的效率要比InnoDB高(当没有事务处理时候选这个更好),没有死锁问题
myisam缺点:不支持事务,不支持行级锁,只支持表级锁所以也没有死锁问题,不支持事务.不支持外键

innodb优点:支持行级锁、支持事务安全,支持外键
innodb缺点:并发事务会出现一些脏读幻读等问题(随事务隔离级别而定),可能会出现死锁

http://www.cnblogs.com/luyucheng/p/6306512.html

记忆关键词:行级锁、表级锁、事务、外键、curd效率、死锁、全文索引

19、简述行级锁、表级锁的各自的优缺点

表级锁:开销小.加锁快,不会出现死锁,锁定粒度大.发生锁冲突的概率最高.并发度最低,

行级锁:开销大.加锁慢,会出现死锁,锁定粒度最小.发生锁冲突的概率最低.并发度也最高,

http://www.cnblogs.com/luyucheng/p/6297752.html

20、InnoDB的行级锁定同样分为共享锁和排他锁两种类型,描述各自使用场景
http://www.cnblogs.com/luyucheng/p/6297752.html

21、MySQL的锁、事务、并发之间的关系是怎样的
https://www.cnblogs.com/chenqionghe/p/4845693.html

22、简述mysql主从复制原理以及作用
	原理:
	1.数据库有个bin-log二进制文件,记录了所有sql语句。
	2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。
	3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。
	4.具体需要三个线程来操作:binlog输出线程、从库I/O线程、从库的SQL线程
	作用:
	做数据的热备,作为后备数据库,主数据库服务器故障后,可切换到从数据库继续工作,避免数据丢失。
	架构的扩展,I/O访问频率过高,单机无法满足,此时做多库的存储,降低磁盘I/O访问的频率，提高单个机器的I/O性能。
	读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master报表使用slave那么报表sql将不会造成前台锁保证了前台速度。	

23、谈谈数据库优化的方式,建表、使用.

24、简述数据库三大范式

表中字段不可分;非主键字段依赖主键中的全部字段（对于关联主键来说;非主键字段不传递依赖于主键;


25、连表查询的种类

26、关于MySQL规范,你有什么建议,设计规范、设计原则.

27、innodb的事务与日志的实现方式,日志存放、如何通过日志实现事务.
https://www.cnblogs.com/panwenbin-logs/p/8366940.html

28、线上环境下MySQL数据库cpu飙升到500%的话该怎么处理
https://www.cnblogs.com/panwenbin-logs/p/8366940.html

29、备份计划,mysqldump以及xtranbackup的实现原理

30、你是如何监控你们的数据库的,你们的慢日志都是怎么查询的

31、表中有大字段X(例如text类型)且字段X不会经常更新,以读为为主,请问您是选择拆成子表,还是继续放一起?写出您这样选择的理由

32、在当前的工作中,你碰到到的最大的 mysql db 问题以及如何解决的

33、请简洁地描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称,以及逐级之间的区别
https://www.cnblogs.com/panwenbin-logs/p/8366940.html

34、数据库事务的四个特性及含义

35、Mysql中什么时候会出现数据丢失、怎样预防数据丢失

36、简述Mysql集群 

37、有没接触过MySQL慢日志监控及报警

38、索引的类型有哪几种,组合索引要遵守什么原则

39、简述MySQL之中,索引、主键、唯一索引、联合索引的区别,对数据库性能有什么影响(从读写两个方面)

40、简述memcache的工作原理

41、分布式数据库集群的话,如果要做数据分析,比如统计书城的用户阅读情况,但是这些阅读数据分布在好几个库,你怎么做数据分析

42、你是否了解数据库的读写分离,如果了解请说一下你们的应用是如何实现读写分离的

43、请说一下MySQL的事务隔离级别以及他们各自可能带来的影响

44、数据库设计经验,一般多少数据量需要做分库分表,分库分表的目的是什么,什么是数据库垂直拆分、水平拆分,可以举例说明

45、数据库优化技巧有哪些,分别需要注意什么

46、简述MySQL的长连接和短连接,你经常用的是哪一种
长连接:长时间保持客户端与服务端的连接状态,主要用于在少数客户端与服务端的频繁通信,容易导致MySQL线程数达到限制阻塞新线程的创建.
短连接：客户端发消息连接才建立（客户端发起），请求消息得到响应后连接关闭；
验证结论：不管用pdo的长连接和短连接,都是在PHP脚本执行完毕或者pdo设置为null的时候,show processlist看到的线程数没了,而Navicat打开新表时候则线程是sleep状态
结论就是不管哪种连接,都是在脚本执行期间共用一个MySQL线程执行完毕后MySQL自动销毁线程,也就是说短连接也没有在一个PHP进程内频繁断开重连,长连接也没有在多个PHP进程之中重复启用,请问长连接的意义在哪里,请问如何减少了客户端和服务端的频繁连接.